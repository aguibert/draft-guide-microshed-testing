//  Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: microshed-testing
:page-layout: guide-multipane
:page-duration: 20 minutes
:page-releasedate: 2019-XX-XX
:page-guide-category: microprofile
:page-essential: true
:page-essential-order: 1
:page-description: Learn how to test a MicroProfile or Jakarta EE application using MicroShed Testing.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Java EE', 'Jakarta EE', 'Testing']
:page-related-guides: ['rest-intro', 'docker', 'rest-client-java']
:page-permalink: /guides/{projectid}
:repo-description: Visit the https://openliberty.io/guides/{projectid}.html[website] for the rendered version of the guide.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
= Testing a MicroProfile or Jakarta EE application

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to test a MicroProfile or Jakarta EE application using MicroShed Testing.

== What you'll learn

You will start with an existing REST application that runs on OpenLiberty, and use https://microshed.org/microshed-testing/[MicroShed Testing] 
to write tests for the application that will exercise the application inside of a Docker container.

Often times tests may pass in dev/test environments, but fail in production because the application is
running differently in production than it is in dev/test. Luckily, we can greatly minimize these dev/prod
parity issues by testing our application as it runs in the same Docker container we'll be using in production.

=== What is Docker?

Docker is a tool that you can use to deploy and run applications with containers. You
can think of Docker like a virtual machine that runs various applications. However, unlike a typical virtual
machine, you can run these applications simultaneously on a single system and independent of
one another.

Learn more about Docker on the https://www.docker.com/what-docker[official Docker page^].

Learn how to install Docker on the https://docs.docker.com/engine/installation[official instructions page^].

[role="command"]
include::{common-includes}/gitclone.adoc[]

=== Try what you'll build

The `finish` directory in the root of this guide contains the finished application. Give it a try before you proceed.

To try out the application, first go to the `finish` directory and run the following Maven 
goal to build the application and run the integration tests on an Open Liberty server in a container:
[role='command']
```
mvn verify
```

This may take some time on the first run, due to downloading dependencies and the Docker image for Open Liberty. If you 
re-run the same command again, it will be considerably faster.

In addition to running integration tests from a cold start, you can use MicroShed Testing to run your tests on
an already running Open Liberty server, such as a server running in Open Liberty's "dev mode":

[role='command']
```
mvn liberty:dev
```

Once the Liberty server starts and you see the message `Press the Enter key to run tests on demand.`, you can press the 
enter key to run the integration tests. Once the tests finish, you can press the Enter key to run the tests again, or you 
can make code changes to the application or tests in between re-running the tests. Open Liberty's dev mode will automatically
recompile and update any application or test code changes that you make.

After you are done running tests in dev mode, stop the Open Liberty server by pressing `CTRL+C`
in the shell session where you ran the server.

== Bootstrapping your application for testing

Navigate to the `start` directory to begin.

Start Open Liberty in development mode, which starts the Open Liberty server and listens 
for file changes:

[role="command"]
```
mvn liberty:dev
```

Press the Enter key to run tests, and you will see that 1 test is run:

[console]
----
[INFO] Running integration tests...
[INFO]
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running io.openliberty.guides.testing.PersonServiceIT
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.024 s - in io.openliberty.guides.testing.PersonServiceIT
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] Integration tests finished.
----

To begin, annotate the `src/test/java/io/openliberty/guides/testing/PersonServiceIT.java` class with the `@MicroShedTest` annotation. This will indicate that the test class uses MicroShed Testing.

[source, Java, linenums, role='code_column']
----
import org.microshed.testing.jupiter.MicroShedTest;

@MicroShedTest
public class PersonServiceIT {
----

Next, we will define some basic information that informs MicroShed Testing if and how it should start our applictaion runtime, and what URL path the application will be available at:

[source, Java, linenums, role='code_column']
----
import org.microshed.testing.testcontainers.MicroProfileApplication;

@MicroShedTest
public class PersonServiceIT {

    @Container
    public static MicroProfileApplication app = new MicroProfileApplication()
                    .withAppContextRoot("/guide-microshed-testing")
                    .withReadinessPath("/health/ready");

}
----

The `withAppContextRoot(String)` method indicates what the base path of the application is. In this case, our application is deployed at http://localhost:9080/guide-microshed-testing, so the app context root is the portion of the URL after the hostname and port.

The `withReadinessPath(String)` method indicates what path should be polled via HTTP to determine application readiness. MicroShed Testing will automatically start or discover the MicroProfileApplication and wait for it to be ready before the tests start to run. In this case, we are utilizing the default application readiness check at http://localhost:9080/health/ready, which is provided by the `mpHealth-2.0` feature in our server.xml configuration. When the readiness URL returns HTTP 200, the application is considered ready and the tests will begin running.

Save your changes to `PersonServiceIT` and press `Enter` in your console window to re-run the tests. You will still see only 1 test running, but the output will be a bit different. Notice that MicroShed Testing is using a "hollow" configuration mode. This means it is re-using an existing application runtime for the test, and not starting up a new application instance each time you initiate a test run.

== Talking to your application with a REST client

With MicroShed Testing we exercise the application in a black-box fashion. This means the tests do not get to access internals of the application. Instead, we can only exercise the application from the "outside", most commonly with HTTP requests. To simplify the HTTP interactions, we can inject a REST client to our test like so:

[source, Java, role='code_column']
----
import javax.inject.Inject;

@MicroShedTest
public class PersonServiceIT {
    
    @Inject
    public static PersonService personSvc;
----

Here the injected type `PersonService` is the same `io.openliberty.guides.testing.PersonService` class that is used in our actual application. However, the _instance_ that gets injected is a REST client proxy. So if we call `personSvc.createPerson("Bob", 42)`, what actually happens is the REST client makes an HTTP POST request to the running application at http://localhost:9080/guide-microshed-testing/people/ which triggers the corresponding Java method in the application.

== Writing your first test

Now that the setup is complete, we can write our first test case. We will start by testing the basic "create person" use case for our REST-based application. To do this, we use the REST client injected by MicroShed Testing to make the HTTP POST request to our application and read the response:

[source, Java, role='code_column']
----
import static org.junit.jupiter.api.Assertions.assertNotNull;

@MicroShedTest
public class PersonServiceIT {

    // ...
    
    @Test
    public void testCreatePerson() {
        Long createId = personSvc.createPerson("Hank", 42);
        assertNotNull(createId);
    }
}
----

Save the changes and press `Enter` in your console window to run the test. You will see that the test ran again and this time exercised the REST endpoint of your application, including the response of your application's endpoint.

[console]
----
INFO org.microshed.testing.jaxrs.RestClientBuilder  - Building rest client for class io.openliberty.guides.testing.PersonService with base path: http://localhost:9080/guide-microshed-testing/ and providers: [class org.microshed.testing.jaxrs.JsonBProvider]
INFO org.microshed.testing.jaxrs.JsonBProvider  - Response from server: 1809686877352335426
----

== Testing error paths

It is also possible to write negative tests using the REST client, along with the new `assertThrows()` method from JUnit 5. This is particularly useful for testing that your application returns the proper error codes such as an HTTP 404 for a GET of a non-existing entity:

[source, Java, role='code_column']
----
import static org.junit.jupiter.api.Assertions.assertNotNull;

@MicroShedTest
public class PersonServiceIT {

    // ...
    
    @Test
    public void testGetUnknownPerson() {
        assertThrows(NotFoundException.class, () -> personSvc.getPerson(-1L));
    }
}
----

In this test method we make an HTTP request to http://localhost:9080/guide-microshed-testing/people/-1 to try and get a person with the ID -1, but since none exist we expect an HTTP 404 in return.

After saving the file, press `Enter` again and you will see that 2 tests run and pass.

== Testing outside of Dev Mode

Running the tests against a pre-started Liberty server is very conveneint for local development, but this may be tedous to set up in non-dev scenarios such as a CI/CD pipeline. For this reason, MicroShed Testing is also capable of starting and stopping the application runtime before and after the tests are executed. This is primarily accomplished using Docker and Testcontainers.

To test ousdie of Dev Mode, first exit Dev Mode by pressing `CTRL+C`.

Next, run the tests from a "cold start" by running the command:
[role='command']
```
mvn verify
```

Running tests from a cold start will take a little longer than running the tests from Dev Mode, but 
TODO @AGG LEFTOFF

== Great work! You're done!

You developed automated tests for a REST service in Open Liberty by using MicroShed Testing and Liberty Dev Mode.

== Related Links

Learn more about MicroProfile.

https://microprofile.io/[See the MicroProfile specs^]

https://openliberty.io/docs/ref/microprofile[View the MicroProfile API^]


include::{common-includes}/attribution.adoc[subs="attributes"]
